<HTML>
<HEAD>
   <TITLE>TclExcept - try</TITLE>
</HEAD>
<BODY>

<H3>
NAME</H3>
try - Exception handling
<H3>
SYNOPSIS</H3>

<PRE><B>try </B><I>script ?</I><B>catch </B><I>msg catchblock? ?</I><B>finally</B><I> finallyscript? ?varName?</I></PRE>
<PRE><B>try </B><I>script ?</I><B>catch </B><I>{type msg} catchblock? ?</I><B>finally</B><I> finallyscript? ?varName?</I></PRE>

<H3>
DESCRIPTION</H3>
The <B>try</B> command is used to catch exceptions or errors generated
by <B><A HREF="throw.htm">throw</A></B> or <B>error</B>. Its use is similar
to <B>catch</B>, but with several differences: it encapsulates exception
catching and handling, whereas <B>catch</B> only does (as its name says)
error catching.

<P>Usually, a test is made on <B>catch</B>'s return value to see if an
error has been caught. In this case, error handling is done depending on
<B>catch</B>'s return code and the <B>errorInfo</B> and <B>errorCode</B>
global variables value. The purpose of <B>try</B> is to gather error catching
and handling in a single statement. To do so, it uses a C++/Java-like exception-handling
syntax.

<P><B>Try</B> first evaluates <I>script</I>. If no error occurs, it then
evaluates (if present) <I>finallyscript </I>following the <B>finally</B>
keyword (borrowed from the Java language). However, if an error occurs,
the evaluation of the script is interrupted and <B>try </B>tries to match
the exception type to one of those defined in the <I>catchblock </I>following
the <B>catch</B> keyword and evaluates the body of the matching type. If
none is found (or if no catch block is present) then it evaluates <I>finallyscript
</I>and propagates the exception to lower levels. The exception is propagated
until it reaches a <B>try</B> or <B>catch</B> statement, or the global
level. It is important to know that <I>finallyscript </I>is always evaluated,
even if the exception is unhandled and propagated. This script is generally
used for clean-up purpose. The <B>finally</B> keyword is a major improvement
to C++ exceptions introduced by Java.

<P>The catch block is very similar to the pattern-body list used with <B>switch</B>.
It is a list (which can be empty) with a <TT>{<I>type body ?type body ...?</I>}
</TT>structure. When an exception is caught, <B>try </B>compares each <I>type
</I>with the exception type (see <B><A HREF="throw.htm">throw</A></B> and
<B><A HREF="exception.htm">exception</A></B> for explanation on exception types
and how they are matched). If the last type is <B>default</B> then
it matches any type. When the first matching type is found, the corresponding
<I>body </I>is evaluated. <I>Msg</I> is the name of a variable that will
contain the exception message that can be used inside catch block bodies, and
with the second form, <I>type</I> will also contain the exception type.

<P>Like in <B>switch</B>, comments are not allowed inside a catch block,
since a catch block is not a valid Tcl script. However, bodies must be
valid Tcl scipts. Thus, unlike <B>switch</B>, the body cannot be specified
as "-" to specify that the following body must be used.

<P><B>Try</B> handles all the exceptions thrown by the <B>throw</B> command.
It also handles regular Tcl errors generated by <B>return</B> and <B>error</B>
commands and by Tcl core commands. In these cases, the exception type is
<B>Error</B>. Future versions of <B>throw </B>are likely to use more precise
exception types (for example, <B>FileException</B> in case of file I/O
error). However, unlike <B>catch</B>, control flow commands such as <B>return</B>,
<B>break</B> or <B>continue</B> are not caught, so you can use <B>try </B>statements
inside a loop, or exit a procedure from within a <B>try</B> statement.

<P>Unlike C++ or Java, exception types are not objects nor structures.
They are just strings. So there is no inheritance relationship between
exception types. This is likely to change in future versions, since exception
subtyping is very handy.

<P>If present, <I>varName </I>is the name of a variable that will contain
the return value of the last evaluated command in any of the scripts.

<P>If no error occurs inside a catch body or the finally script, then <B>try</B>,
like <B>catch</B>, returns a decimal string giving the code returned by
the script. In this case, <B>try</B> behaves like <B>catch</B>, except
that it does not catch <B>return</B>/<B>break</B>/<B>continue</B> exceptions.
However, errors that occur inside a catch body or a finally script are
not handled and then raise an error.

<H3>EXAMPLES</H3>
<UL>
<PRE><B>try {
&nbsp;&nbsp;&nbsp;&nbsp;puts "begin"
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;throw MyException "something very strange just happened..."
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;puts "end"
} catch msg {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;MyException {puts "MyException caught: $msg"}
&nbsp;&nbsp;&nbsp;&nbsp;...
}</B></PRE>
</UL>
will print:
<UL>
<PRE><B>begin
MyException caught: something very strange just happened...
1</B></PRE>
</UL>
What happened:

<P><B>Try</B> first evaluates the main script. It first prints "<B>begin</B>".
The "<B>throw ...</B>" command throws an exception of type <B>MyException</B>.
The main script evaluation is then interrupted, and since there is a <B>catch</B>
keyword, <B>try</B> looks for the first matching exception type, which
is present, and evaluates its body, thus prints the error message. The
<B>1</B> is the value returned by <B>try</B>, indicating that an error
occurred.
<UL>
<PRE><B>try {
&nbsp;&nbsp;&nbsp;&nbsp;puts "begin"
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;throw MyException "something very strange just happened..."
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;puts "end"
} catch msg {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;MyException {puts "MyException caught: $msg"}
&nbsp;&nbsp;&nbsp;&nbsp;...
} finally {
&nbsp;&nbsp;&nbsp;&nbsp;puts "finally"
}</B></PRE>
</UL>
will print:
<UL>
<PRE><B>begin
MyException caught: something very strange just happened...
finally
1</B></PRE>
</UL>
This is the same example as above, except that there is a <B>finally</B>
keyword. The finally script is then evaluated.
<UL>
<PRE><B>try {
&nbsp;&nbsp;&nbsp;&nbsp;puts "begin"
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;throw UnhandledException "something very strange just happened..."
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;puts "end"
} catch msg {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;MyException {puts "MyException caught: $msg"}
&nbsp;&nbsp;&nbsp;&nbsp;...
} finally {
&nbsp;&nbsp;&nbsp;&nbsp;puts "finally"
}</B></PRE>
</UL>
will print:
<UL>
<PRE><B>begin
finally
UnhandledException exception thrown: something very strange just happened...</B></PRE>
</UL>
There is no exception type matching <B>UnhandledException </B>here, so
the exception is propagated, but after the finally script being evaluated.
The last line is the error message received at global level.
<UL>
<PRE><B>try {
&nbsp;&nbsp;&nbsp;&nbsp;puts "begin"
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;throw UnhandledException "something very strange just happened..."
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;puts "end"
} catch msg {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;MyException {puts "MyException caught: $msg"}
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;default {puts "exception caught: $msg"}
} finally {
&nbsp;&nbsp;&nbsp;&nbsp;puts "finally"
}</B></PRE>
</UL>
will print:
<UL>
<PRE><B>begin
exception caught: something very strange just happened...
finally
1</B></PRE>
</UL>
Here the <B>default</B> keyword in the catch block matches the <B>UnhandledException</B>.
<UL>
<PRE><B>try {
&nbsp;&nbsp;&nbsp;&nbsp;puts "begin"
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;error "this is an error"
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;puts "end"
} catch msg {
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;Error {puts "error caught: $msg"}
&nbsp;&nbsp;&nbsp;&nbsp;...
} finally {
&nbsp;&nbsp;&nbsp;&nbsp;puts "finally"
}</B></PRE>
</UL>
will print:
<UL>
<PRE><B>begin
error caught: this is an error
finally
1</B></PRE>
</UL>
The <B>Error</B> exception type matches regular Tcl errors.

<P>Examples of <B>try</B> inside loops:
<UL>
<PRE><B>for {set i 0} {$i &lt; 10} {incr i} {
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if {$i == 5} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts $i
&nbsp;&nbsp;&nbsp;&nbsp;}
}</B></PRE>
</UL>
will print numbers from 0 to 9 not including 5. Thus the <B>continue</B> is 
correctly propagated. The following:
<UL>
<PRE><B>for {set i 0} {$i &lt; 10} {incr i} {
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if {$i == 5} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts $i
&nbsp;&nbsp;&nbsp;&nbsp;}
}</B></PRE>
</UL>
will print numbers from 0 to 4. The following:
<UL>
<PRE><B>for {set i 0} {$i &lt; 10} {incr i} {
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if {$i == 5} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;} finally {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts $i
&nbsp;&nbsp;&nbsp;&nbsp;}
}</B></PRE>
</UL>
will print numbers from 0 to 5. The difference is that the <B>puts</B> is
inside a <B>finally</B> block, and thus gets executed even after the loop
has been broken.

<P>Example of <B>try</B> within a proc:
<UL>
<PRE><B>proc a {} {
&nbsp;&nbsp;&nbsp;&nbsp;puts "begin"
&nbsp;&nbsp;&nbsp;&nbsp;try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for {set i 0} {$i &lt; 10} {incr i} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if {$i == 5} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts $i
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;} finally {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puts "finally"
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;puts "end"
}</B></PRE>
</UL>
will print "<B>begin</B>", numbers from 0 to 4 then "<B>finally</B>",
but not "<B>end</B>".

<P>Of course, <B>try</B> statements can be nested. You can put them within
any Tcl control structure, within a <B>catch</B> script, within a <B>try</B>
main script, catch body or finally script, and in anything that can be
evaluated by Tcl. Put them everywhere!
<H3>
KNOWN BUGS/LIMITATIONS</H3>
When using <B>return</B> from within a <B>try</B>, <B>catch</B> or <B>finally</B> block with a non-error code, <B>-errorinfo</B> and <B>-errorcode</B>
options have no effect. But since <B>catch</B> behaves the same, this should
be called a feature, or compatibility ;-)
<H3>
SEE ALSO</H3>
catch(n), error(n), return(n), <A HREF="throw.htm">throw</A>, <A HREF="exception.htm">exception</A>
<H3>
KEYWORDS</H3>
error, exception
</BODY>
</HTML>
